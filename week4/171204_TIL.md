# 12월 4일(월)

## 강의노트

### JavaScript 

- 강의자료: [패스트캠퍼스 JavaScript 파트 강의자료 Gitbook](https://javascript-fds.netlify.com/)
- 실습 링크: [repl.it](repl.it/languages/babel)

* * *

#### JavaScript에 관하여

- ECMAScript 2015
    - 새로운 요소가 많이 추가되면서, 이제는 프로그래밍 언어로서의 면모가 손색 없음.
    - 한편, 브라우저 호환성 문제가 있음.
        - transpiler: 언어에서의 변경.
            - TypeScript: 기능을 확장시켜주는 트랜스파일러
            - Babel
        - polyfill: 구동환경 안에 기능이 추가되는 경우
            - 옛 브라우저에서 최신 기능을 사용하고 싶을 때!
- 이용중인 환경의 JavaScript 기능 지원 여부 확인하기!

- JS는 많은 환경을 지원한다
    - 언어는 같지만, 구동 환경에 따라서 지원하는 내용이 다르다!
    - alert는 웹브라우저가 아닌 곳에서도 가능할까?

#### JavaScript의 실행

* 코드의 실행
    * 기본적으로 JavaScript 코드는 세미콜론(;)으로 구분된 구문(statement) 단위로 위에서부터 차례대로 실행.
    * 그러나 제어 흐름, 예외 처리, 함수 호출 등을 만나면 코드의 실행 흐름이 이리저리 옮겨다니기도 한다.

* 대소문자의 구분
    * 꼭 지켜야 함 (HTML, CSS와 다름)

* 세미콜론과 공백
    * 다른 사람들이 보기 좋도록 만드는 것도 고려해야 함.

#### 값과 리터럴

* 값(value): 메모리에 올라가는 것. 상태(데이터)

* 리터럴(literal): 값을 위한 표기법.
    * 정수 / 부동소수점 실수, 문자열, 참/거짓, null, undefined

#### 타입

* 자료형(date type) 혹은 타입
    * 원시자료형: boolean, undefined, null, string, number + symbol
    * 참조자료형: object

* `typeof`: typeof 연산자는 피연산자의 타입을 가리키는 문자열을 반환

```js
typeof 1 // 'number'
typeof 2.5 // 'number'
typeof 'hello world' // 'string'
typeof true // 'boolean'
typeof null // 'object'
typeof undefined // 'undefined'
// ...
```

* `null`과 `undefined`의 차이

```js
let a;
typeof a // undefined

let b = null;
typeof b // object
```

#### 표현식(expression)과 연산자(operator)

* 표현식
    * JavaScript 문장의 구성요소를 구분하는 하나의 단위로, 값으로 변환될 수 있는 부분.
    * 값, 변수, 연산자의 조합이며 이 조합은 연산을 통해 하나의 값을 만든다. 즉, 표현식은 하나의 값으로 평가될 수 있는 문장이다. 5 * 10은 50으로 평가(연산)된다. (poiemaweb)

* 연산자는 +, -, *, / 같은 것.

* 연산자 우선순위 (operator precedence)
    * 우선순위를 다 외우기에는 어려우니, 괄호가 우선순위가 제일 높으므로 괄호로 묶어주는 것이 좋음.

#### 변수(variable)

* 여러 번 값을 재사용하기 위한 것.
    * 변수를 이용하면, 값에 이름을 붙일 수 있다.
    * 한 가지 물건을 넣을 수 있는 상자. 다른 물건을 넣으려면 원래 있던 물건을 빼면 된다!
![상자](http://slidesplayer.org/slide/11329564/61/images/4/%EB%B3%80%EC%88%98+=+%EC%83%81%EC%9E%90+%EB%B3%80%EC%88%98%EB%8A%94+%EB%AC%BC%EA%B1%B4%EC%9D%84+%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94+%EC%83%81%EC%9E%90%EC%99%80+%EA%B0%99%EB%8B%A4.+int+%EB%8D%B0%EC%9D%B4%ED%84%B0+%EB%B3%80%EC%88%98%EC%9D%98+%ED%83%80%EC%9E%85+%EB%B3%80%EC%88%98%EC%9D%98+%EC%9D%B4%EB%A6%84.jpg)

* 할당: 값을 설정하는 것.

* `const`: 바뀔 필요 없는 변수를 담아놓을 때
* `let`: 재대입이 가능
    * `let`을 사용하면 의도치 않게 다른 값이 재할당이 될 수 있으므로, 진짜 필요할 때만 사용하고 웬만하면 `const`를 사용하는 것이 좋다!


```js
const jeesoo; // (X) 선언과 동시에 값을 담아야 함
```


```js
let seven = 7;
let seven = 77; // (X) 재선언이 안됨

seven = 77; // (O) 재할당은 가능
```

* * *

**변수에 대한 재미있는(!) 이야기**
- 왜 변수를 선언하고 나면, 콘솔은 `undefined;` 라는 대답을 하는 걸까?
    - 명령이 값을 반환하지 않을 때마다 이렇게 답한다.
    - 변수를 만들었다고 해서, 값이 반환되는 것은 아니다.

* * *

* 식별자(identifier)
    * 변수의 이름을 식별자라고 한다
    * 숫자, 알파벳, $, 언더스코어(_) 다 포함은 되는데, 숫자로 시작하는 건 안 되고, [예약어](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Lexical_grammar#Reserved_keywords_as_of_ECMAScript_6)도 안 된다.
        * camel case: 식별자에 들어가는 각 단어의 첫 글자를 대문자로 써주는 것
        * snake case: 대문자 말고 언더바를 이용해서 써줄 때

#### 제어 구조 (control structures)

* 조건문(conditional): "만약 어떤 내용이 참이라면 이걸 실행하고, 참이 아니면 저걸 실행해!"
* 반복문(loop): "어떤 내용이 참인 동안에는 이걸 계속 실행하라구!"

* if문, for문, while문 실습

```js
// if 구문
const 이름 = "레오나르도 디카프리오";
if (이름.length > 7){
    console.log("우와, 정말 긴 이름이네요!");
} else {
    console.log("대단히 긴 이름은 아니군요!");
}

// for 구문
for (let i = 0; i < 5; i++) { // (초기 조건; 종료 조건; )
  console.log(`이 코드는 ${i + 1}번 째 실행되고 있습니다.`);
}

// while 구문
let numSheep = 0;

while (numSheep < 10){
    console.log(`양을 ${numSheep} 마리까지 셌어요!`);
    numSheep++;
}

console.log('ZzzzZzzzzz');
```

#### 함수 (function)
* 코드 뭉치에 이름을 붙여서 재사용
    * 코드를 반복해서 복-붙하지 않아도 프로그램 여기저기에서 똑같은 코드를 여러 차례 사용할 수 있다.
    * 긴 코드를 함수 안에 감춰두고 이해하기 쉬운 이름을 붙여두면 함수를 구성하는 자잘한 코드보다 여러 함수를 구조화하는 데 집중할 수 있어 코드를 계획적으로 작성할 수 있다.

```js
const multiply = (x, y) => x * y;

function multiply(x, y){
return x * y;
}

const catDrawing = function (num) {
    for (let i = 0; i <num; i++){
        console.log(i + " =^.^=");
    }
};
```

* 호출: 함수 내부에 있는 코드를 실행하려면 불러야 (call) 한다. `함수();` 식으로 입력.
* 반환 값: 함수에서 출력해 나중에 코드 다른 부분에서 사용할 수 있는 값.
* 인수(argument): 특정한 값을 전달하여 호출할 때마다 함수의 동작을 바꿀 수 있음.

#### 객체
* 객체는 여러 개의 값을 한꺼번에 담는 통(container) 같은 것.
* 이름, 값 / 메소드

```js
// 객체의 생성
const obj = {
  x: 0, // 객체의 속성. 속성 이름: x, 속성 값: 0
  y: 1,
  increaseX: function() { // 객체의 메소드
    this.x += 1
  }
}

// 객체의 속성에 접근하기
obj.x;
obj['y'];

// 객체의 속성 변경하기
obj.x += 1;
obj['y'] -=1;

// 객체의 속성 삭제하기
delete obj.x;
```

#### 배열
* 다른 자바스크립트 데이터 값을 하나의 목록으로 만든 것. 대괄호`[]`를 사용한다.

```js
const 패캠강의장1 = '신관';
const 패캠강의장2 = '본관';
const 패캠강의장3 = '별관';
const 패캠강의장4 = '강남강의장';
const 패캠강의장5 = '성수캠퍼스';
const 패캠강의장6 = '리틀스타';

// 하나로 합친다면?
const 패캠강의장 = ['신관', '본관', '별관', '강남강의장', '성수캠퍼스', '리틀스타']
```

* `[1,2,3,'a','b',{x:o, y:0, name:'원점'}];`
* `arr.push('four')` : 추가 

```js
// 배열의 생성
const arr = ['one', 'two', 'three'];

// 인덱스를 사용해 배열의 요소(element)에 접근하기
// 배열 인덱스(index)는 0부터 시작합니다.
arr[0]; // === 'one'
arr[1]; // === 'two'

// 여러 타입의 값이 들어있는 배열
[1, 2, 3, 'a', 'b', {x: 0, y: 0, name: '원점'}];

// 배열에 요소 추가하기
arr.push('four');

// 배열의 요소 삭제하기
arr.splice(3, 1); // 인덱스가 3인 요소부터 시작해서 하나를 삭제합니다.
```

#### 이상한 숫자: NaN, 0, Infinity
- NaN
    - 계산이 안되는 연산의 결과값
    - NaN은 어느 숫자와도 같으면 안 된다고 하는데, 그래서 `NaN === NaN 이 false`이다.
    - NaN은 무엇과 비교해도 false 가 나온다.

#### parseInt, parseFloat
- 스트링에서 숫자형으로 바꿔주기 위해 사용.

#### Math 객체
- 주사위 만들기
    - Math.ceil(Math.random()*6);

#### 아스키 코드, 유니코드


* * *

- MDN을 빨리 검색하는 팁!
    - http://devdocs.io/

* * *

#### 부동소수점
- 이진수로 소수도 표현이 가능하다. 컴퓨터가 소수를 이진수밖에 다루지 못한다.
- 1101.011 (2) => 1*2^3+1*2^2+1*2^0+0*2^(-1)+1*2^(-2)+1*2^(-3)  - 0.1이라는 십진수 소수를 나타내기 위해서는?
    - `0 * 1/2 + 0 * 1/4 + 0* 1/8 + 1 * 1/16 + 1 * 1/32 + ...` 에서 계산을 통해 최대한 가깝게 맞춰야 한다.
    - 컴퓨터가 만들어진 방식에서 소수를 다룰 때는 정확하게 다룰 수가 없음.
    - 하지만 현실에서 0.1이라는 소수를 쓰기는 한다.
- 메모리에 저장되는 0.1이라는 값에는 아주 작지만 오차가 존재. (반올림 오차 / 라운딩)
- 자바스크립트가 아니라 컴퓨터가 그런 것. 다른 프로그래밍 언어도 비슷하다.
- 자바스크립트 내장 연산으로는 불가능.
- 미리 구현해둔 라이브러리를 써야 한다.


* * *

#### 컴퓨터과학 기초

##### 메모리(주 기억장치), CPU, HDD/SSD(보조기억장치), 가상메모리

![메모리 하드디스크 그림](http://mooc.phinf.nhnnext.org/20170717_35/1500267098736lgVUm_PNG/1.2_-01.png)

(CS50 X edwith 발췌)

컴퓨터의 하드웨어는 크게 중앙처리장치, 기억장치, 입출력장치로 구성됩니다.

중앙처리장치(Central Processing Unit, CPU)는 프로세서라고 불리기도 하는데, 입력장치에서 받은 명령을 실제로 처리합니다. CPU가 1초에 얼마나 많은 연산을 할 수 있는지 속도를 측정하는 단위는 기가헤르츠(GHz)입니다.

기억장치는 입력된 명령이나 데이터가 저장되는 공간으로, **주기억장치**와 **보조기억장치**로 나누어집니다. 주기억장치에는 우리가 흔히 들어본 RAM이 있습니다. RAM은 기억된 정보를 읽어내기도 하고 다른 정보를 기억시킬 수 있는 메모리로서, 응용 프로그램을 일시적으로 불러오거나, 데이터를 일시적으로 저장하는데 사용되는 임의 접근 기억 장치입니다. RAM이 메모리에 얼마나 많은 양의 정보를 저장할 수 있는지 측정하는 단위는 보통 기가바이트(GB)가 사용됩니다.

주기억장치인 RAM이 일시적으로 데이터를 저장하는 것과 달리, 하드드라이브(C:)는 영구적으로 데이터를 저장합니다. 이런 하드드라이브를 보조기억장치라고 하는데, 많이 쓰이는 하드디스크(Hard Disk Drive, HDD)는 원판 모양의 플래터를 회전시켜 드라이브에 데이터를 읽고 쓰는 원리입니다. 하드드라이브는 다양한 용량이 존재하는데 보통 기가바이트(GB)나 테라바이트(TB) 단위가 쓰입니다. 

(...)

CPU는 용량이 매우 큰 파일이나 데이터를 처리해야 하지만, 한번에 32 또는 64bit의 블록 단위로 굉장히 적은 양의 데이터를 조작하고 계산합니다. 하지만 **중앙처리장치**는 이러한 비트들을 굉장히 빠른 속도로 처리할 수 있습니다.

이와 정 반대로 하드디스크는 CPU보다 훨씬 많은 양의 데이터를 저장할 수 있습니다. 근래의 하드디스크는 기기바이트나 테라바이트 단위의 데이터를 저장할 수 있습니다. 하드디스크는 엄청나게 많은 양의 데이터를 기억장치에 저장할 수는 있지만, 데이터를 읽고 쓰는 데에 많은 시간이 소요됩니다.

이 중간에 있는 것이 임의 접근 기억장치, 즉 RAM입니다. RAM은 하드디스크보다 훨씬 빠르게 데이터를 읽고 쓸 수 있어서, 실행중인 프로그램이나 열려있는 파일들이 더 빨리 접근될 수 있도록 메모리를 저장하는 데에 쓰입니다.

##### 비트와 바이트

- 비트
    - 이진 숫자라는 뜻을 가진 “binary digit”의 줄임말
    - 0과 1, 두 가지 값만 가질 수 있는 측정 단위
    - 컴퓨터 내부에서 물리적 표현될 때는, 켜고 끌 수 있는 스위치라고 생각할 수 있다! (켜기=1, 끄기=0)
    - 

- 바이트
    - 비트 한 개는 많은 양의 데이터를 나타내기에 턱없이 부족
    - 여덟 개의 비트가 모여 만들어진 비트열
    - 하나의 바이트에 여덟 개의 비트가 있고, 비트 하나는 0과 1로 표현될 수 있기 때문에 2^8 = 256 개의 서로 다른 바이트가 존재할 수 있음
    - 킬로바이트는 1,000 바이트, 메가바이트는 1,000 킬로바이트(100만 바이트), 기가바이트는 1,000 메가바이트(10억 바이트), 테라바이트는 1,000 기가바이트(1조 바이트) 등.

##### 아스키코드
텍스트 문자를 0과 1을 이용해 나타내야 하는데, ASCII는 컴퓨터가 이해할 수 있는 이진 데이터로 문자를 변환하는 표준 방법. 

![아스키코드 표현](http://mooc.phinf.nhnnext.org/20170719_44/1500450003932QrON0_PNG/1.5_-01.png)

8비트 아스키코드로는 나타낼 수 없는 문자가 많이 생기면서, Unicode 가 생겨났다. 
- [graphemica 사이트: 문자를 유니코드로 보여주는 사이트](http://graphemica.com/unicode/characters)

* * *

### 기타 용어 정리
- REPL(Read-Evaluate-Print-Loop): 실행하면 한 줄씩 결과를 보여줌.

